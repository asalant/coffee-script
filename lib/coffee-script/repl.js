// Generated by CoffeeScript 1.4.0
(function() {
  var ACCESSOR, CoffeeScript, Module, REPLServer, REPL_PROMPT, REPL_PROMPT_CONTINUATION, REPL_PROMPT_MULTILINE, SIMPLEVAR, Script, autocomplete, completeAttribute, completeVariable, enableColours, error, getCompletions, inspect, readline, stdin, stdout,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  stdin = process.openStdin();

  stdout = process.stdout;

  CoffeeScript = require('./coffee-script');

  readline = require('readline');

  inspect = require('util').inspect;

  Script = require('vm').Script;

  Module = require('module');

  REPL_PROMPT = 'coffee> ';

  REPL_PROMPT_MULTILINE = '------> ';

  REPL_PROMPT_CONTINUATION = '......> ';

  enableColours = false;

  if (process.platform !== 'win32') {
    enableColours = !process.env.NODE_DISABLE_COLORS;
  }

  error = function(err) {
    return stdout.write((err.stack || err.toString()) + '\n');
  };

  ACCESSOR = /\s*([\w\.]+)(?:\.(\w*))$/;

  SIMPLEVAR = /(\w+)$/i;

  autocomplete = function(text) {
    return completeAttribute(text) || completeVariable(text) || [[], text];
  };

  completeAttribute = function(text) {
    var all, candidates, completions, key, match, obj, prefix, _i, _len, _ref;
    if (match = text.match(ACCESSOR)) {
      all = match[0], obj = match[1], prefix = match[2];
      try {
        obj = Script.runInThisContext(obj);
      } catch (e) {
        return;
      }
      if (obj == null) {
        return;
      }
      obj = Object(obj);
      candidates = Object.getOwnPropertyNames(obj);
      while (obj = Object.getPrototypeOf(obj)) {
        _ref = Object.getOwnPropertyNames(obj);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          if (__indexOf.call(candidates, key) < 0) {
            candidates.push(key);
          }
        }
      }
      completions = getCompletions(prefix, candidates);
      return [completions, prefix];
    }
  };

  completeVariable = function(text) {
    var candidates, completions, free, key, keywords, r, vars, _i, _len, _ref;
    free = (_ref = text.match(SIMPLEVAR)) != null ? _ref[1] : void 0;
    if (text === "") {
      free = "";
    }
    if (free != null) {
      vars = Script.runInThisContext('Object.getOwnPropertyNames(Object(this))');
      keywords = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = CoffeeScript.RESERVED;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          r = _ref1[_i];
          if (r.slice(0, 2) !== '__') {
            _results.push(r);
          }
        }
        return _results;
      })();
      candidates = vars;
      for (_i = 0, _len = keywords.length; _i < _len; _i++) {
        key = keywords[_i];
        if (__indexOf.call(candidates, key) < 0) {
          candidates.push(key);
        }
      }
      completions = getCompletions(free, candidates);
      return [completions, free];
    }
  };

  getCompletions = function(prefix, candidates) {
    var el, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = candidates.length; _i < _len; _i++) {
      el = candidates[_i];
      if (0 === el.indexOf(prefix)) {
        _results.push(el);
      }
    }
    return _results;
  };

  process.on('uncaughtException', error);

  REPLServer = (function() {

    function REPLServer(options) {
      var backlog, multilineMode, rli,
        _this = this;
      if (options == null) {
        options = {};
      }
      multilineMode = false;
      backlog = '';
      this.lastValueKey = options.lastValueKey || '_';
      this["eval"] = options["eval"] || function(code, context, filename, modulename, callback) {
        var returnValue;
        try {
          returnValue = CoffeeScript["eval"]("(" + code + "\n)", {
            filename: filename,
            modulename: modulename,
            sandbox: context
          });
          return callback(null, returnValue);
        } catch (err) {
          return callback(err);
        }
      };
      this.rli = rli = stdin.readable && stdin.isRaw ? this.createPipedInterface(stdin) : this.createReadlineInterface();
      rli.input.on('keypress', function(char, key) {
        var cursorPos, newPrompt;
        if (!(key && key.ctrl && !key.meta && !key.shift && key.name === 'v')) {
          return;
        }
        cursorPos = rli.cursor;
        rli.output.cursorTo(0);
        rli.output.clearLine(1);
        multilineMode = !multilineMode;
        if (!multilineMode && backlog) {
          rli._line();
        }
        backlog = '';
        rli.setPrompt((newPrompt = multilineMode ? REPL_PROMPT_MULTILINE : REPL_PROMPT));
        rli.prompt();
        return rli.output.cursorTo(newPrompt.length + (rli.cursor = cursorPos));
      });
      rli.input.on('keypress', function(char, key) {
        if (!(multilineMode && rli.line)) {
          return;
        }
        if (!(key && key.ctrl && !key.meta && !key.shift && key.name === 'd')) {
          return;
        }
        multilineMode = false;
        return rli._line();
      });
      rli.on('attemptClose', function() {
        if (multilineMode) {
          multilineMode = false;
          rli.output.cursorTo(0);
          rli.output.clearLine(1);
          rli._onLine(rli.line);
          return;
        }
        if (backlog || rli.line) {
          backlog = '';
          rli.historyIndex = -1;
          rli.setPrompt(REPL_PROMPT);
          rli.output.write('\n(^C again to quit)');
          return rli._line((rli.line = ''));
        } else {
          return rli.close();
        }
      });
      rli.on('close', function() {
        rli.output.write('\n');
        return rli.input.destroy();
      });
      rli.on('line', function(buffer) {
        var code;
        buffer = buffer.replace(/(^|[\r\n]+)(\s*)##?(?:[^#\r\n][^\r\n]*|)($|[\r\n])/, "$1$2$3");
        buffer = buffer.replace(/[\r\n]+$/, "");
        if (multilineMode) {
          backlog += "" + buffer + "\n";
          rli.setPrompt(REPL_PROMPT_CONTINUATION);
          rli.prompt();
          return;
        }
        if (!buffer.toString().trim() && !backlog) {
          rli.prompt();
          return;
        }
        code = backlog += buffer;
        if (code[code.length - 1] === '\\') {
          backlog = "" + backlog.slice(0, -1) + "\n";
          rli.setPrompt(REPL_PROMPT_CONTINUATION);
          rli.prompt();
          return;
        }
        rli.setPrompt(REPL_PROMPT);
        backlog = '';
        try {
          _this["eval"](code, null, 'repl', 'repl', function(err, returnValue) {
            if (err != null) {
              return error(err);
            }
            if (returnValue !== void 0) {
              global[_this.lastValueKey] = returnValue;
            }
            return rli.output.write("" + (inspect(returnValue, false, 2, enableColours)) + "\n");
          });
        } catch (_error) {}
        return rli.prompt();
      });
    }

    REPLServer.prototype.start = function() {
      this.rli.setPrompt(REPL_PROMPT);
      return this.rli.prompt();
    };

    REPLServer.prototype.createPipedInterface = function(stdin) {
      var piped, pipedInput,
        _this = this;
      pipedInput = '';
      piped = {
        prompt: function() {
          return stdout.write(this._prompt);
        },
        setPrompt: function(p) {
          return this._prompt = p;
        },
        input: stdin,
        output: stdout,
        on: function() {}
      };
      stdin.on('data', function(chunk) {
        var line, lines, _i, _len, _ref;
        pipedInput += chunk;
        if (!/\n/.test(pipedInput)) {
          return;
        }
        lines = pipedInput.split("\n");
        pipedInput = lines[lines.length - 1];
        _ref = lines.slice(0, -1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          if (!(line)) {
            continue;
          }
          stdout.write("" + line + "\n");
          _this.run(line);
        }
      });
      stdin.on('end', function() {
        var line, _i, _len, _ref;
        _ref = pipedInput.trim().split("\n");
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          if (!(line)) {
            continue;
          }
          stdout.write("" + line + "\n");
          _this.run(line);
        }
        stdout.write('\n');
        return process.exit(0);
      });
      return piped;
    };

    REPLServer.prototype.createReadlineInterface = function() {
      var rli;
      if (readline.createInterface.length < 3) {
        rli = readline.createInterface(stdin, autocomplete);
        stdin.on('data', function(buffer) {
          return rli.write(buffer);
        });
      } else {
        rli = readline.createInterface(stdin, stdout, autocomplete);
      }
      return rli;
    };

    return REPLServer;

  })();

  new REPLServer().start();

}).call(this);
